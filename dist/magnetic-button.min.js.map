{"version":3,"sources":["../src/umd.ts","../node_modules/.pnpm/@phucbm+lerp@1.0.1/node_modules/@phucbm/lerp/src/index.ts","../src/index.ts"],"sourcesContent":["/**\n * UMD entry point with auto-initialization and global API\n * This file creates the browser-friendly version that auto-initializes on load\n */\n\nimport {MagneticButton as MagneticButtonClass, type MagneticButtonOptions} from './index'\n\n// Auto-initialize all magnetic buttons when script loads\nnew MagneticButtonClass()\n\n// Create global API with MagneticButton as constructor\nconst MagneticButtonAPI = MagneticButtonClass as any\n\n// Add init method for convenience\nMagneticButtonAPI.init = (target?: HTMLElement | null, options?: MagneticButtonOptions) => {\n    return new MagneticButtonClass(target, options)\n}\n\n// Export as default for IIFE global\nexport default MagneticButtonAPI\n\n// Also attach to window for direct access\nif (typeof window !== 'undefined') {\n    ;(window as any).MagneticButton = MagneticButtonAPI\n}","/**\n * Linear interpolation function for smooth animation\n * @param start - Starting value\n * @param end - Target value\n * @param fraction - Interpolation factor (0 = no change, 1 = instant change), default: 0.1\n * @returns Interpolated value between start and end\n */\nexport function lerp(start: number, end: number, fraction: number = 0.1): number {\n    return start * (1 - fraction) + end * fraction;\n}\n\n// Default export for convenience\nexport default lerp;\n","import lerp from \"@phucbm/lerp\";\n\n/**\n * Configuration options for the magnetic button effect\n */\nexport interface MagneticButtonOptions {\n    /** CSS class added when the magnetic effect is active */\n    activeClass?: string;\n    /** Controls the strength of the magnetic pull (0 = weak, 1 = strong) */\n    attraction?: number;\n    /** Defines the range within which the magnetic effect is active (in pixels) */\n    distance?: number;\n    /** Controls the speed of the magnetic movement (0 = slow, 1 = instant) */\n    speed?: number;\n    /** Disable magnetic effect on touch devices (default: true) */\n    disableOnTouch?: boolean;\n    /** Callback fired when mouse enters the magnetic area */\n    onEnter?: (data: MagneticData) => void;\n    /** Callback fired when mouse exits the magnetic area */\n    onExit?: (data: MagneticData) => void;\n    /** Callback fired continuously while mouse is in the magnetic area */\n    onUpdate?: (data: MagneticData) => void;\n    /** Maximum horizontal movement in pixels (optional constraint) */\n    maxX?: number | undefined;\n    /** Maximum vertical movement in pixels (optional constraint) */\n    maxY?: number | undefined;\n}\n\n/**\n * Data object containing magnetic effect calculations\n */\nexport interface MagneticData {\n    /** Horizontal offset from element center */\n    deltaX: number;\n    /** Vertical offset from element center */\n    deltaY: number;\n    /** Distance between mouse and element center */\n    distance: number;\n}\n\n/**\n * Position coordinates for interpolation\n */\ninterface LerpPosition {\n    x: number;\n    y: number;\n}\n\n/**\n * MagneticButton class creates magnetic attraction effects for HTML elements\n *\n * Usage:\n * ```html\n * <button data-magnetic data-distance=\"150\" data-attraction=\"0.3\" data-speed=\"0.2\">\n *   Hover me!\n * </button>\n * ```\n *\n * ```typescript\n * import { MagneticButton } from 'magnetic-button';\n *\n * // Auto-initialize all elements with data-magnetic attribute\n * new MagneticButton();\n *\n * // Or target specific element\n * const button = document.querySelector('.my-button');\n * new MagneticButton(button, { distance: 200, attraction: 0.5 });\n * ```\n */\nexport class MagneticButton {\n\n    private readonly settings: Required<MagneticButtonOptions> = {\n        activeClass: 'magnetizing',\n        attraction: 0.3,\n        distance: 50,\n        speed: 0.1,\n        disableOnTouch: true,\n        // @ts-ignore\n        maxX: undefined,\n        // @ts-ignore\n        maxY: undefined,\n        onEnter: () => {\n        },\n        onExit: () => {\n        },\n        onUpdate: () => {\n        },\n    };\n    private isEnter: boolean = false;\n    private lerpPos: LerpPosition = {x: 0, y: 0};\n    private target: HTMLElement | null = null;\n    private boundMagnetize: ((e: MouseEvent) => void) | null = null;\n\n    // Track initialized elements to avoid duplicates\n    private static initializedElements = new WeakSet<HTMLElement>();\n\n    /**\n     * Detects if the device is primarily a touch device\n     * @returns true if the device uses touch as primary input\n     */\n    private static isTouchDevice(): boolean {\n        // Check if primary input is touch (coarse pointer without hover capability)\n        return window.matchMedia(\"(hover: none) and (pointer: coarse)\").matches;\n    }\n\n    /**\n     * Creates a new MagneticButton instance\n     * @param target - The HTML element to apply magnetic effect to. If null, auto-initializes all elements with data-magnetic attribute\n     * @param options - Configuration options for the magnetic effect\n     */\n    constructor(target?: HTMLElement | null, options: MagneticButtonOptions = {}) {\n        // If no target is provided, select all elements with data-magnetic attribute\n        if (!target) {\n            document.querySelectorAll<HTMLElement>('[data-magnetic]').forEach(element => {\n                // Skip if already initialized\n                if (!MagneticButton.initializedElements.has(element)) {\n                    new MagneticButton(element, options);\n                }\n            });\n            return; // Exit constructor if initializing multiple instances\n        }\n\n        // Skip if this element is already initialized\n        if (MagneticButton.initializedElements.has(target)) {\n            return;\n        }\n\n        // Mark as initialized\n        MagneticButton.initializedElements.add(target);\n\n        // Extract and validate data attributes\n        const dataDistance = parseFloat(target.getAttribute('data-distance') || '');\n        const dataAttraction = parseFloat(target.getAttribute('data-attraction') || '');\n        const dataSpeed = parseFloat(target.getAttribute('data-speed') || '');\n        const dataMaxX = parseFloat(target.getAttribute('data-max-x') || '');\n        const dataMaxY = parseFloat(target.getAttribute('data-max-y') || '');\n\n        // Merge default settings with options and data attributes\n        this.settings = {\n            ...this.settings,\n            attraction: !isNaN(dataAttraction) ? dataAttraction : options.attraction ?? this.settings.attraction,\n            distance: !isNaN(dataDistance) ? dataDistance : options.distance ?? this.settings.distance,\n            speed: !isNaN(dataSpeed) ? dataSpeed : options.speed ?? this.settings.speed,\n            maxX: !isNaN(dataMaxX) ? dataMaxX : options.maxX ?? this.settings.maxX,\n            maxY: !isNaN(dataMaxY) ? dataMaxY : options.maxY ?? this.settings.maxY,\n            ...options,\n        };\n\n        // Skip initialization on touch devices if disableOnTouch is true\n        if (this.settings.disableOnTouch && MagneticButton.isTouchDevice()) {\n            // Remove from initialized elements so it can be retried if needed\n            MagneticButton.initializedElements.delete(target);\n            return;\n        }\n\n        this.target = target;\n        this.boundMagnetize = (e: MouseEvent) => this.magnetize(target, e);\n\n        // Watch for mouse move events\n        window.addEventListener('mousemove', this.boundMagnetize);\n\n        // Add identification class\n        target.classList.add('is-magnetized');\n    }\n\n    /**\n     * Main magnetization logic - processes mouse movement and applies magnetic effect\n     * @param target - The target element\n     * @param e - Mouse event\n     */\n    private magnetize(target: HTMLElement, e: MouseEvent): void {\n        const data = this.calculateCoordinates(target, e.clientX, e.clientY);\n\n        if (data.distance < this.settings.distance) {\n            // Mouse is inside magnetized area\n            this.animateButton(target, data.deltaX, data.deltaY);\n\n            if (!this.isEnter) {\n                this.isEnter = true;\n                target.classList.add(this.settings.activeClass);\n                this.settings.onEnter(data);\n            }\n\n            this.settings.onUpdate(data);\n        } else {\n            // Mouse is outside - return to origin\n            this.animateButton(target, 0, 0);\n\n            if (this.isEnter) {\n                this.isEnter = false;\n                target.classList.remove(this.settings.activeClass);\n                this.settings.onExit(data);\n            }\n        }\n    }\n\n\n    /**\n     * Applies smooth animation to the button using transform\n     * @param target - The target element\n     * @param endX - Target X position\n     * @param endY - Target Y position\n     */\n    private animateButton(target: HTMLElement, endX: number, endY: number): void {\n        // Get interpolated position values\n        this.lerpPos.x = lerp(this.lerpPos.x, endX, this.settings.speed);\n        this.lerpPos.y = lerp(this.lerpPos.y, endY, this.settings.speed);\n\n        // Apply constraints if defined\n        let finalX = this.lerpPos.x;\n        let finalY = this.lerpPos.y;\n\n        if (this.settings.maxX !== undefined) {\n            finalX = Math.max(-this.settings.maxX, Math.min(this.settings.maxX, finalX));\n        }\n\n        if (this.settings.maxY !== undefined) {\n            finalY = Math.max(-this.settings.maxY, Math.min(this.settings.maxY, finalY));\n        }\n\n        // Apply transform with constrained values\n        target.style.transform = `translate(${finalX}px, ${finalY}px)`;\n    }\n\n    /**\n     * Calculates distances and coordinates between mouse and element center\n     * @param target - The target element\n     * @param mouseX - Mouse X coordinate\n     * @param mouseY - Mouse Y coordinate\n     * @returns Object containing delta values and distance\n     */\n    private calculateCoordinates(target: HTMLElement, mouseX: number, mouseY: number): MagneticData {\n        const viewportOffset = target.getBoundingClientRect();\n\n        // Center point of target relative to viewport\n        const centerX = viewportOffset.left + target.offsetWidth / 2;\n        const centerY = viewportOffset.top + target.offsetHeight / 2;\n\n        // Calculate delta with attraction factor\n        const deltaX = (mouseX - centerX) * this.settings.attraction;\n        const deltaY = (mouseY - centerY) * this.settings.attraction;\n\n        // Calculate distance from bounding rect edges\n        const distanceX = Math.max(0, Math.abs(mouseX - centerX) - target.offsetWidth / 2);\n        const distanceY = Math.max(0, Math.abs(mouseY - centerY) - target.offsetHeight / 2);\n        const distance = Math.sqrt(distanceX * distanceX + distanceY * distanceY);\n\n        return {deltaX, deltaY, distance};\n    }\n\n    /**\n     * Returns the total magnetized area dimensions\n     * @returns Object containing width and height of the magnetized area\n     */\n    public getMagnetizedArea(): { width: number; height: number } {\n        if (!this.target) {\n            return {width: 0, height: 0};\n        }\n\n        return {\n            width: this.target.offsetWidth + this.settings.distance * 2,\n            height: this.target.offsetHeight + this.settings.distance * 2\n        };\n    }\n\n    /**\n     * Destroys the magnetic button instance and cleans up all event listeners\n     */\n    public destroy(): void {\n        if (this.boundMagnetize) {\n            window.removeEventListener('mousemove', this.boundMagnetize);\n            this.boundMagnetize = null;\n        }\n\n        if (this.target) {\n            this.target.classList.remove('is-magnetized', this.settings.activeClass);\n            this.target.style.transform = '';\n            MagneticButton.initializedElements.delete(this.target);\n            this.target = null;\n        }\n\n        this.isEnter = false;\n        this.lerpPos = {x: 0, y: 0};\n    }\n}\n\n/**\n * Auto-initialize magnetic buttons when DOM is ready (only in browser environment)\n */\nif (typeof window !== 'undefined' && typeof document !== 'undefined') {\n    if (document.readyState === 'loading') {\n        document.addEventListener('DOMContentLoaded', () => new MagneticButton());\n    } else {\n        new MagneticButton();\n    }\n}\n\nexport default MagneticButton;"],"mappings":"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","names":["umd_exports","__export","umd_default","lerp","start","end","fraction","index_default","_MagneticButton","target","options","element","dataDistance","dataAttraction","dataSpeed","dataMaxX","dataMaxY","e","data","endX","endY","b","finalX","finalY","mouseX","mouseY","viewportOffset","centerX","centerY","deltaX","deltaY","distanceX","distanceY","distance","MagneticButton","MagneticButton","MagneticButtonAPI","target","options","umd_default"]}