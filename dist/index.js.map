{"version":3,"sources":["../src/index.ts"],"sourcesContent":["import lerp from \"@phucbm/lerp\";\n\n/**\n * Configuration options for the magnetic button effect\n */\nexport interface MagneticButtonOptions {\n    /** CSS class added when the magnetic effect is active */\n    activeClass?: string;\n    /** Controls the strength of the magnetic pull (0 = weak, 1 = strong) */\n    attraction?: number;\n    /** Defines the range within which the magnetic effect is active (in pixels) */\n    distance?: number;\n    /** Controls the speed of the magnetic movement (0 = slow, 1 = instant) */\n    fraction?: number;\n    /** Disable magnetic effect on touch devices (default: true) */\n    disableOnTouch?: boolean;\n    /** Callback fired when mouse enters the magnetic area */\n    onEnter?: (data: MagneticData) => void;\n    /** Callback fired when mouse exits the magnetic area */\n    onExit?: (data: MagneticData) => void;\n    /** Callback fired continuously while mouse is in the magnetic area */\n    onUpdate?: (data: MagneticData) => void;\n}\n\n/**\n * Data object containing magnetic effect calculations\n */\nexport interface MagneticData {\n    /** Horizontal offset from element center */\n    deltaX: number;\n    /** Vertical offset from element center */\n    deltaY: number;\n    /** Distance between mouse and element center */\n    distance: number;\n}\n\n/**\n * Position coordinates for interpolation\n */\ninterface LerpPosition {\n    x: number;\n    y: number;\n}\n\n/**\n * MagneticButton class creates magnetic attraction effects for HTML elements\n *\n * Usage:\n * ```html\n * <button data-magnetic data-distance=\"150\" data-attraction=\"0.3\" data-fraction=\"0.2\">\n *   Hover me!\n * </button>\n * ```\n *\n * ```typescript\n * import { MagneticButton } from 'magnetic-button';\n *\n * // Auto-initialize all elements with data-magnetic attribute\n * new MagneticButton();\n *\n * // Or target specific element\n * const button = document.querySelector('.my-button');\n * new MagneticButton(button, { distance: 200, attraction: 0.5 });\n * ```\n */\nexport class MagneticButton {\n    private readonly settings: Required<MagneticButtonOptions> = {\n        activeClass: 'magnetizing',\n        attraction: 0.3,\n        distance: 50,\n        fraction: 0.1,\n        disableOnTouch: true,\n        onEnter: () => {\n        },\n        onExit: () => {\n        },\n        onUpdate: () => {\n        },\n    };\n    private isEnter: boolean = false;\n    private lerpPos: LerpPosition = {x: 0, y: 0};\n    private target: HTMLElement | null = null;\n    private boundMagnetize: ((e: MouseEvent) => void) | null = null;\n\n    // Track initialized elements to avoid duplicates\n    private static initializedElements = new WeakSet<HTMLElement>();\n\n    /**\n     * Detects if the device is primarily a touch device\n     * @returns true if the device uses touch as primary input\n     */\n    private static isTouchDevice(): boolean {\n        // Check if primary input is touch (coarse pointer without hover capability)\n        return window.matchMedia(\"(hover: none) and (pointer: coarse)\").matches;\n    }\n\n    /**\n     * Creates a new MagneticButton instance\n     * @param target - The HTML element to apply magnetic effect to. If null, auto-initializes all elements with data-magnetic attribute\n     * @param options - Configuration options for the magnetic effect\n     */\n    constructor(target?: HTMLElement | null, options: MagneticButtonOptions = {}) {\n        // If no target is provided, select all elements with data-magnetic attribute\n        if (!target) {\n            document.querySelectorAll<HTMLElement>('[data-magnetic]').forEach(element => {\n                // Skip if already initialized\n                if (!MagneticButton.initializedElements.has(element)) {\n                    new MagneticButton(element, options);\n                }\n            });\n            return; // Exit constructor if initializing multiple instances\n        }\n\n        // Skip if this element is already initialized\n        if (MagneticButton.initializedElements.has(target)) {\n            return;\n        }\n\n        // Mark as initialized\n        MagneticButton.initializedElements.add(target);\n\n        // Extract and validate data attributes\n        const dataDistance = parseFloat(target.getAttribute('data-distance') || '');\n        const dataAttraction = parseFloat(target.getAttribute('data-attraction') || '');\n        const dataFraction = parseFloat(target.getAttribute('data-fraction') || '');\n\n        // Merge default settings with options and data attributes\n        this.settings = {\n            ...this.settings,\n            attraction: !isNaN(dataAttraction) ? dataAttraction : options.attraction ?? this.settings.attraction,\n            distance: !isNaN(dataDistance) ? dataDistance : options.distance ?? this.settings.distance,\n            fraction: !isNaN(dataFraction) ? dataFraction : options.fraction ?? this.settings.fraction,\n            ...options,\n        };\n\n        // Skip initialization on touch devices if disableOnTouch is true\n        if (this.settings.disableOnTouch && MagneticButton.isTouchDevice()) {\n            // Remove from initialized elements so it can be retried if needed\n            MagneticButton.initializedElements.delete(target);\n            return;\n        }\n\n        this.target = target;\n        this.boundMagnetize = (e: MouseEvent) => this.magnetize(target, e);\n\n        // Watch for mouse move events\n        window.addEventListener('mousemove', this.boundMagnetize);\n\n        // Add identification class\n        target.classList.add('is-magnetized');\n    }\n\n    /**\n     * Main magnetization logic - processes mouse movement and applies magnetic effect\n     * @param target - The target element\n     * @param e - Mouse event\n     */\n    private magnetize(target: HTMLElement, e: MouseEvent): void {\n        const data = this.calculateCoordinates(target, e.clientX, e.clientY);\n\n        if (data.distance < this.settings.distance) {\n            // Mouse is inside magnetized area\n            this.animateButton(target, data.deltaX, data.deltaY);\n\n            if (!this.isEnter) {\n                this.isEnter = true;\n                target.classList.add(this.settings.activeClass);\n                this.settings.onEnter(data);\n            }\n\n            this.settings.onUpdate(data);\n        } else {\n            // Mouse is outside - return to origin\n            this.animateButton(target, 0, 0);\n\n            if (this.isEnter) {\n                this.isEnter = false;\n                target.classList.remove(this.settings.activeClass);\n                this.settings.onExit(data);\n            }\n        }\n    }\n\n\n    /**\n     * Applies smooth animation to the button using transform\n     * @param target - The target element\n     * @param endX - Target X position\n     * @param endY - Target Y position\n     */\n    private animateButton(target: HTMLElement, endX: number, endY: number): void {\n        // Get interpolated position values\n        this.lerpPos.x = lerp(this.lerpPos.x, endX, this.settings.fraction);\n        this.lerpPos.y = lerp(this.lerpPos.y, endY, this.settings.fraction);\n\n        // Apply transform\n        target.style.transform = `translate(${this.lerpPos.x}px, ${this.lerpPos.y}px)`;\n    }\n\n    /**\n     * Calculates distances and coordinates between mouse and element center\n     * @param target - The target element\n     * @param mouseX - Mouse X coordinate\n     * @param mouseY - Mouse Y coordinate\n     * @returns Object containing delta values and distance\n     */\n    private calculateCoordinates(target: HTMLElement, mouseX: number, mouseY: number): MagneticData {\n        const viewportOffset = target.getBoundingClientRect();\n\n        // Center point of target relative to viewport\n        const centerX = viewportOffset.left + target.offsetWidth / 2;\n        const centerY = viewportOffset.top + target.offsetHeight / 2;\n\n        // Calculate delta with attraction factor\n        const deltaX = (mouseX - centerX) * this.settings.attraction;\n        const deltaY = (mouseY - centerY) * this.settings.attraction;\n\n        // Calculate distance from bounding rect edges\n        const distanceX = Math.max(0, Math.abs(mouseX - centerX) - target.offsetWidth / 2);\n        const distanceY = Math.max(0, Math.abs(mouseY - centerY) - target.offsetHeight / 2);\n        const distance = Math.sqrt(distanceX * distanceX + distanceY * distanceY);\n\n        return {deltaX, deltaY, distance};\n    }\n\n    /**\n     * Returns the total magnetized area dimensions\n     * @returns Object containing width and height of the magnetized area\n     */\n    public getMagnetizedArea(): { width: number; height: number } {\n        if (!this.target) {\n            return {width: 0, height: 0};\n        }\n\n        return {\n            width: this.target.offsetWidth + this.settings.distance * 2,\n            height: this.target.offsetHeight + this.settings.distance * 2\n        };\n    }\n\n    /**\n     * Destroys the magnetic button instance and cleans up all event listeners\n     */\n    public destroy(): void {\n        if (this.boundMagnetize) {\n            window.removeEventListener('mousemove', this.boundMagnetize);\n            this.boundMagnetize = null;\n        }\n\n        if (this.target) {\n            this.target.classList.remove('is-magnetized', this.settings.activeClass);\n            this.target.style.transform = '';\n            MagneticButton.initializedElements.delete(this.target);\n            this.target = null;\n        }\n\n        this.isEnter = false;\n        this.lerpPos = {x: 0, y: 0};\n    }\n}\n\n/**\n * Auto-initialize magnetic buttons when DOM is ready (only in browser environment)\n */\nif (typeof window !== 'undefined' && typeof document !== 'undefined') {\n    if (document.readyState === 'loading') {\n        document.addEventListener('DOMContentLoaded', () => new MagneticButton());\n    } else {\n        new MagneticButton();\n    }\n}\n\nexport default MagneticButton;"],"mappings":"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","names":[]}